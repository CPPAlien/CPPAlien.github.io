<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android沉浸式UI，看这一篇就够了]]></title>
    <url>%2F2017-08-06%2Fimmersion-ui%2F</url>
    <content type="text"><![CDATA[前言Android对这种沉浸式风格的支持跨度了好几个版本，真正系统级别的完全支持要到Android 6.0，而从Android 3.0开始就多多少少有了点这种沉浸式风格的影子。从3.0到6.0，期间跨度了五个大版本，每个版本都多多少少做了些优化，加入了些新特性。所以如果我们想要一个比较完美的沉浸式实现，还得能尽可能支持低版本，将会是个很有挑战性的任务，期间会遇到各种各样兼容性问题。为了让大家少走弯路，下面我会按照版本的升级顺序，一点点说明每个版本中加入的新特性，让大家知道这种沉浸式风格是怎么一点点发展来的。 3.0（API 11）大家还记得我们在Android 3.0以前代码上是如何隐藏状态栏的吗？我想早前做过Android开发的应该都对下面这段代码比较熟悉吧。 1getWindow().addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN); 在3.0之前，我们并没有一个专门针对状态栏进行操作的API。而如果我们想要要隐藏状态栏来达到全屏效果，只能通过对Window设置全屏标签获得。后来在Android 3.0版本（API 11）上，View中加入了一个void setSystemUiVisibility (int visibility) 方法。随着该方法一同出来的有两个属性：STATUS_BAR_HIDDEN、STATUS_BAR_VISIBLE。并且还加入了View.OnSystemUiVisibilityChangeListener来监听系统UI的变化。至此Android开启了可以对状态栏进行操作的时代，也为以后的各种花样玩法打下了基础。不过在3.0上你能操作的也只有显示或隐藏状态栏了，并无其他。 4.0（API 14）后来在4.0上，扩充了针对状态栏操作的功能，把3.0种加入的STATUS_BAR_HIDDEN 换成了SYSTEM_UI_FLAG_LOW_PROFILE ， STATUS_BAR_VISIBLE 也换成了 SYSTEM_UI_FLAG_VISIBLE。另外还加入了SYSTEM_UI_FLAG_HIDE_NAVIGATION这个新标签。开发者对系统UI的控制权进一步加强。 SYSTEM_UI_FLAG_LOW_PROFILE 被称为低调模式，我们可以设置该标签让状态栏或导航栏上的图标变暗和让一些不重要的图标消失。适用一些全屏操作，比如游戏，阅读等。我们来看下设置该标签后的效果。左边为默认样式，右边为设置该标签后的样子，可以明显看到状态栏一些ICON被隐藏了，并且变得有些半透明，导航栏的三个按钮也都被隐藏了。另外只要页面有任何交互，该标签会被清除，样式还原。 SYSTEM_UI_FLAG_HIDE_NAVIGATION 故名思意就是可以通过设置该标签，使得底部的导航栏隐藏。Android也正是从4.0版本开始可以对底部导航栏进行操作的。同样如果用户与页面有任何交互，该标签会被清除，样式会还原。 4.1（API 16）在4.1版本中，Android团队进一步强化了setSystemUiVisibility的作用，又在4.0的基础上增加了以下一些属性： SYSTEM_UI_FLAG_FULLSCREEN 全屏状态，视觉上的作用和WindowManager.LayoutParams.FLAG_FULLSCREEN一样。如果你的应用只是某几个页面需要使用全屏模式，建议使用该标签来设置。因为此标签更容易清除。 SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN / SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION 这两个属性和上面提到的FULLSCREEN和HIDE_NAVIGATION属性很像，只是多了一个LAYOUT。区别是，这两个属性并不会真正隐藏状态栏或者导航栏，只是把整个content的可布局区域延伸到了其中。如下所示Toolbar的布局已经延伸到了状态栏下面。 SYSTEM_UI_FLAG_LAYOUT_STABLE 此View一般和上面几个提到的属性一起使用，它可以保证在系统控件隐藏显示时，不会让本view重新layout。也就是你手动隐藏状态栏或导航栏时，所有的view也都待在本来的位置上不会动。 4.4（API 19）针对以上提到的版本中的状态栏，我们只能进行显示或隐藏的操作。并不能完全达到我们想要的沉浸式效果。我们想要状态栏与下方页面内容的风格更加统一，而且该显示的状态也不能丢，如下所示。 从Android 4.4 开始，我们才能真正做到以上这种效果，在API 19上加入了以下两个风格属性，使用这两种属性，可以设置状态栏或者导航栏的背景为透明。12android:windowTranslucentStatusandroid:windowTranslucentNavigation 设置这两个属性后，需要注意的是，它在Android 4.4 上的效果和 Android 5.0 和之后版本上，表现出的效果不太一样。我们来实地演示下，在values-v19目录下的styles.xml中加入以下代码。 1234&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt; &lt;item name=&quot;android:windowTranslucentStatus&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;android:windowTranslucentNavigation&quot;&gt;true&lt;/item&gt;&lt;/style&gt; 并且设置AppTheme为应用主题，然后分别运行在Android 4.4和5.0上。我们会看到如下效果 我们会看到在4.4上的效果和5.0上的不一样，在4.0上为全透明，但上部有些许阴影，而在5.0上则为均匀的半透明。这可能是因为Android团队在4.4上实现此种风格时，并没有考虑到状态栏的背景可能是白色的情况，而在4.4上我们又不能更改状态栏内容的颜色。到了5.0的时候他们发现了这个问题的存在，但可能发现的比较晚，没有时间加上修改状态栏内容颜色的特性，所以干脆把这种默认风格变为半透明，这样就避开了背景为浅色调的问题。以上纯属个人猜测。 除了上面两个属性外，另外在API 19中还加入了两个标签 SYSTEM_UI_FLAG_IMMERSIVE 正如前面所说的 SYSTEM_UI_FLAG_HIDE_NAVIGATION和SYSTEM_UI_FLAG_FULLSCREEN在用户与屏幕有任何交互时，都会被清除。过后如需隐藏目的，又得重新设置。而此标签正是防止这种情况而加入，设置此标签后，只有从屏幕上方下滑，或者从屏幕下方上滑时才会执行清除，其他普通交互不会变化。 SYSTEM_UI_FLAG_IMMERSIVE_STICKY 该标签与SYSTEM_UI_FLAG_IMMERSIVE作用差不多，只是该标签会让SYSTEM_UI_FLAG_HIDE_NAVIGATION和SYSTEM_UI_FLAG_FULLSCREEN 标签被短暂清除，而不是永久，一会儿后又会自动恢复。 5.0（API 21）从第一次可以操作状态栏的3.0版本（2011年发布）到可以设置状态栏的颜色的5.0版本（2014年发布），已经过去了漫长的3年时间，这三年间，开发者门根本没法实现一个体验比较完美的沉浸式应用。到5.0版本，加入了以下两个属性。 12android:statusBarColorandroid:navigationBarColor 通过以上两个风格属性的设定，我们可以把状态栏和导航栏改变成任何你想要的颜色了。所以我们要在5.0上实现上面4.4开篇提到的沉浸式风格，那首先设置SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN标签。 1234if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; getWindow().getDecorView().setSystemUiVisibility( View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN );&#125; 然后在风格中加入一条，让状态栏背景透明 1&lt;item name=&quot;android:statusBarColor&quot;&gt;@android:color/transparent&lt;/item&gt; 不过这样做后，我们会发现一个问题，Toolbar上部分与状态栏重合了。要解决这个问题，我们就需要用到fitSystemWindows（对应方法：setFitsSystemWindows）了。此属性设置在view上，让该view在计算大小时可以考虑留给系统UI的空间。如下我们在布局的Toolbar中加入android:fitsSystemWindows=&quot;true&quot; 123456&lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/toolbar&quot; android:background=&quot;#00AEFF&quot; android:fitsSystemWindows=&quot;true&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;/&gt; 这样该Toolbar的上部分就会留出状态栏部分（和padding差不多），从而实现了该种沉浸式效果。至此我们算是可以实现沉浸式UI了。但Android却还留了个大坑给我们，那就是我们没法设置状态栏上的内容颜色，这会导致，如果你的页面风格为浅色调，那状态栏上的内容你就基本看不见了，而这个坑一直到6.0上才得到了解决，兼容之难，可想而知。 6.0（API 23）6.0上加入了SYSTEM_UI_FLAG_LIGHT_STATUS_BAR标签和android:windowLightStatusBar风格属性，终于你可以改变状态栏中的内容颜色了。设置后，状态栏的内容会变成暗色调，这样即使在浅色的背景上显示，也一样能看清了，如下 后记Android开发一大之痛就是兼容性问题，而如果你想开发一款比较好的具有沉浸式UI风格的APP，那你肯定会为Android的兼容性问题抓狂。一种功能，特性实现却被分散到了各个不同版本，即使Android新版本加上了新特性你也没法使用，因为Android版本新版本覆盖速度是出了名的慢。感觉这也正证明了Google的Android团队在技术的产品设计上还是有些欠缺的。 作者简介彭涛(@彭涛me) 致力于让技术变得易懂且有趣个人博客：http://pengtao.me简书：http://www.jianshu.com/u/f9246f41945eGitHub：https://github.com/CPPAlien]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从Titlebar到Actionbar再到Toolbar]]></title>
    <url>%2F2017-06-04%2Ftitlebar-actionbar-toolbar%2F</url>
    <content type="text"><![CDATA[写在前面bar在英语中有“门闩（shuān）”之意，我想大家一看到“闩”这个字就能马上联想到bar是啥了。当然Android中对bar的定义和门闩还是有不少区别的。Android中的bar有引导使用之作用，快速让用户了解当前页面的功能和相关操作等。本着这个原则就有了下面的bar的发展史。 从Titlebar到Actionbar在3.0之前，Android在UI设计上还是比较简单粗暴的，当时对这个bar的作用定义也极为简单，就是为显示当前页面的标题，名字都命名成了Titlebar，意为标题bar。对这个bar能做的操作也很单一，设置标题，再或者加个logo啥的，再有复杂的就得自己自定义View了。这个bar长相就如下图所示，可以说丑到爆了。和当时iOS漂亮的界面简直一个天一个地，那个时代可以说是Android的试水期，只追求功能可用，而其他方面就不管了。 当时Android在操作设计上是有物理返回按钮的，所以这个Titlebar连返回都不支持。而在那个设计往往都要对标iOS的时代，Android程序员只能自己去扩展这个功能单一的Titlebar了。自己辛苦得模仿实现iOS应用上那些漂亮的导航栏功能。 1getWindow().setFeatureInt(Window.FEATURE_CUSTOM_TITLE, R.layout.custom_title_bar); 经过几年的发展，到Android 2.3版本，Android的各大功能基本稳定了，Android界开始对美和使用方便性有了强烈的呼声。于是2011年Google发布了Android 3.0版本，这个版本的Android在UI设计上进行了大改，除了引入了大家熟悉的Fragment外，也开始把Titlebar替换为Actionbar。Actionbar顾名思义，这个bar就不当当只是展示标题了，而是加入了Action（动作）。Android3.0的发布相当于Android一个试错的旧时代的结束，一个高速发展的新时代的开始，虽然Android3.0本身应用的范围很小。 Actionbar时代Actionbar主要功能除了显示Title外，还提供了一致的导航和视觉体验，突出了应用的关键操作。比如你可以使用SetDisplayHomeAsUpEnabled(true)添加向上导航，这样在点击Actionbar左边的应用图标时会返回父视图。 你还可以使用Menu的方式来添加当前页面的操作按钮。 你甚至还可以在Actionbar中自定义自己的View，比如你可以 或者在Actionbar中加入页面切换的功能，配合Fragment的机制 另外Actionbar还提供了样式设定，多屏幕适配等等功能。算是解决了Titlebar的痛点，Android在顶部导航这一块终于有了自己的风格，而不再唯iOS是瞻。 啊哈，Toolbar又随着时代的发展，到了2014年，Android5.0发布，这个版本的发布标志着Android又进入了一个新时代，快速爆发的时代过去了，从现在起，要变得优雅，要有自己统一的风格。所以在这个版本上Google推出了Material Design设计语言。然后Actionbar就被重整了，Actionbar虽方便使用，功能也很强大。但它最大的缺点就是不够灵活，比如它默认只能在顶部，要想把Actionbar移到屏幕其它位置就会非常麻烦，因为它在设计上是绑定在DecorView的。你可以到com.android.internal.policy.DecorView中看到相关源码，比如有下面这段，把Actionbar固定在了顶部，并且横向填充。 123456789mShowPrimaryActionModePopup = new Runnable() &#123; public void run() &#123; mPrimaryActionModePopup.showAtLocation( mPrimaryActionModeView.getApplicationWindowToken(), Gravity.TOP | Gravity.FILL_HORIZONTAL, 0, 0); endOnGoingFadeAnimation(); ... &#125;&#125;; 为了满足Material Design优雅而灵活的设计原则，Google推出了更加灵活的Toolbar。你可以在一个Activity中声明多个Toolbar并且放在任意位置。并且你可以在自己的Toolbar中塞入任何你想要的View。Toolbar不是Actionbar的替代，Toolbar是Actionbar的布局方式的扩展，就像一个家庭的小孩长大了，它可以去外面干更多的事情，而也可以回家继续做一个晚辈。所以我们可以自己定义一个Toolbar，然后调用setActionBar()来让这个Toolbar充当Actionbar的功能，前提你需要把当前Activity主题或feature设为NoActionBar。 Toolbar的使用这里只简单介绍下Toolbar的一种用法。关于Toolbar的详细用法，可以参考：Google的官方文档。我们用向Toolbar中加入一个搜索按钮来举个例子。 首先你需要在布局中加入toolbar，可以如普通View一样放在布局的任意位置，并且在Activity的onCreate方法中设置该toolbar为actionbar。1234567&lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/toolbar&quot; android:layout_width=&quot;match_parent&quot; android:background=&quot;@color/colorPrimary&quot; android:layout_height=&quot;48dp&quot;/&gt;setSupportActionBar((Toolbar) findViewById(R.id.toolbar)); 然后创建一个包含搜索按钮的menu，内容如下：123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt; &lt;item android:id=&quot;@+id/action_search&quot; android:icon=&quot;@android:drawable/ic_menu_search&quot; android:title=&quot;Search&quot; app:showAsAction=&quot;ifRoom&quot;/&gt;&lt;/menu&gt; 最后在对应的Activity中加入该menu，就能得到如下图所示的效果了。12345@Overridepublic boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.test_menu, menu); return true;&#125; TIPS：有人可能注意到在使用showAsAction时使用了app作为命名空间，而非使用android。这个是一个历史遗留问题，因为ActionBar是在Android 3.0上引入的，它也具有android:showAsAction这个属性，所以appcompat-v7包为了向下兼容，就用了自定义属性来避免冲突。 原文地址：http://pengtao.me/2017-06-04/titlebar-actionbar-toolbar/ 作者简介CPPAlien(@彭涛me) 如有疑问，你可以通过以下方式联系我Blog：http://pengtao.meGithub：https://github.com/CPPAlien简书：http://www.jianshu.com/u/f9246f41945e]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>发展史</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[APK安装过程]]></title>
    <url>%2F2017-05-15%2Fapk-installation-process%2F</url>
    <content type="text"><![CDATA[当你安装一个APK包时，有没有思考过此时你的手机做了哪些操作呢？做完这些操作后，一个应用就算在手机上安装成功，进而这个应用就可以被运行呢？下面我们来一步步的探讨下。 当你点击安装后，首先是APK中的AndroidManifest.xml被解析，解析的内容会被存储到/data/system/packages.xml和/data/system/packages.list中。我们打开packages.list和packages.xml，找到Demo应用包名，如下图 packages.list中指名了该应用默认存储的位置/data/data/cn.hadcn.example，packages.xml中包含了该应用申请的权限、签名和代码所在位置等信息，并且两者都有一个userId为10060。之所以每个应用都有一个userId，是因为Android在系统设计上把每个应用当作Linux系统上的一个用户对待，这样就可以利用已有的Linux上用户管理机制来设计Android应用，比如应用目录，应用权限，应用进程管理等。 做完以上操作，就相当于应用在系统注册了，可以被系统识别。接下来就得保存应用的执行文件了，根据packages.xml中指定的codePath，创建一个目录，apk会被命名成base.apk并拷贝到此，其中lib目录用来存放native库。如下图所示 注：目录是由 包名-1 组成，有时候此处是 -2。这是为了升级使用，升级时会新创建一个-1 或 -2的目录，如果升级成功，则删除原目录并更改packages.xml中codePath到新目录 此时应用就可以运行了，但如果每次应用运行还得去base.apk中取dex文件，效率就太低了。为了提升效率，Android系统在应用安装时还会做些优化操作，把可所有运行的dex文件单独提取放在一块并做些优化。在Dalvik模式下，会使用dexopt把base.apk中的dex文件优化为odex，存储在/data/dalvik-cache中，如果是ART模式，则会使用dex2oat优化成oat文件也存储在该目录下，并且文件名一样，但文件大小会大很多，因为ART模式会在安装时把dex优化为机器码，所以在ART模式下的应用运行更快，但apk安装速度相对Dalvik模式下变慢，并且会占用更多的ROM。 优化后的dex文件被载入到虚拟机中就可以运行。 参考 http://stackoverflow.com/questions/12442979/android-understanding-the-apk-installation-process 作者简介彭涛(@彭涛me) 致力于让技术变得易懂且有趣个人博客：http://pengtao.me, GitHub地址：https://github.com/CPPAlien]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android中的OutOfMemoryError]]></title>
    <url>%2F2016-12-06%2FOutOfMemoryError%2F</url>
    <content type="text"><![CDATA[OOM 的产生在使用C或C++语言时，我们可操作的内存空间就是整个设备的物理内存，程序员需要自己声明内存空间，也需要自己在恰当的时机释放掉内存，一旦出错就会造成内存泄漏。而Java语言为了解决这个问题，在操作系统之上创造了一个Java虚拟机（JVM），让Java语言编译后的字节码运行在此虚拟机之上。启动一个Java应用，会首先启动JVM，JVM 会向操作系统申请所需内存，然后把内存分成为栈内存和堆内存。堆内存用以存放对象实例，并可被Java回收机制回收，一旦剩余堆内存空间不够申请新对象时就会产生OutOfMemoryError异常。 Android内存管理Android的Dalvik虚拟机（DVM）是参考JVM做出来的，所以大同小异。最主要的两个区别是：一，DVM 基于寄存器，而JVM基于栈来进行局部变量的操作，当然在性能上DVM会更快；二，在DVM上运行的是被进一步处理的JAVA字节码，后缀为.dex，.dex 是把Java应用中所有的.class文件合并而成，缩减了包的体积。Android中的 DVM 如 JVM 一样对每个应用可使用的最大内存空间做了限制，每台设备出厂之前厂家就对单个 DVM 实例可使用的最大内存进行了限定。Android届的第一款手机HTC G1的大小为16M。这些信息储存在手机中 /system/build.prop配置文件中，如下我这是我使用的华为6p plus手机的相关信息 1234567891011adb shellshell@hwPE:/ $ cat /system/build.prop...dalvik.vm.heapstartsize=8mdalvik.vm.heapgrowthlimit=192mdalvik.vm.heapsize=512mdalvik.vm.heaptargetutilization=0.75dalvik.vm.heapminfree=512kdalvik.vm.heapmaxfree=8m... dalvik.vm.heapstartsize为一个应用初始分配的堆大小，越大意味着应用第一次启动时越流畅，但也意味着内存耗用越快。 dalvik.vm.heapgrowthlimit 这就是所谓的单个应用可使用的最大内存堆大小。 dalvik.vm.heapsize 此项表示应用在manifest中配置android:largeHeap=”true”时可使用的最大内存堆大小。 获取内存配置有些小伙伴可能使用过以下方法来获得内存信息，但可能就和最初的我一样，不知道这些获得的数据到底是啥意思。下面我们就来说说每个方法所获得的数据的意义和特点。 1234567Log.e(&quot;pengtao&quot;, &quot;max memory = &quot; + Runtime.getRuntime().maxMemory());Log.e(&quot;pengtao&quot;, &quot;free memory = &quot; + Runtime.getRuntime().freeMemory());Log.e(&quot;pengtao&quot;, &quot;total memory = &quot; + Runtime.getRuntime().totalMemory());ActivityManager am = (ActivityManager) getSystemService(ACTIVITY_SERVICE);Log.e(&quot;pengtao&quot;, &quot;memoryClass = &quot; + Integer.toString(am.getMemoryClass()));Log.e(&quot;pengtao&quot;, &quot;largememoryClass = &quot; + Integer.toString(am.getLargeMemoryClass())); Runtime.getRuntime().maxMemory() 这个参数对应到build.prop中的信息就是在未设置largeHeap为true时会返回heapgrowthlimit的大小，而设置了largeHeap为true后，则返回heapsize大小。单位为Bytes。 getMemoryClass 所获得的大小不受largeHeap配置影响，永远是heapgrowthlimit中大小。而getLargeMemoryClass则为heapsize大小，两者单位都为M。 最后要想理解totalMemory和freeMemory概念可以看下下图。 上述日志代码执行后，在我手机上跑出来的结果如下（设置了largeHeap为true），可以把这些数据与build.prop中的数据对应起来： 1234512-05 16:01:50.346 29178-29178/? E/pengtao: max memory = 53687091212-05 16:01:50.346 29178-29178/? E/pengtao: free memory = 820151412-05 16:01:50.346 29178-29178/? E/pengtao: total memory = 2536126612-05 16:01:50.346 29178-29178/? E/pengtao: memoryClass = 19212-05 16:01:50.346 29178-29178/? E/pengtao: largememoryClass = 512 注：谨慎设置largeHeap，因为越大的堆空间意味着GC（垃圾回收）需要遍历的对象越多，时间就会越久。不过largeHeap配置是从Android 3.0开始支持的，而并发式的GC是从Android 2.3后开始支持，所以虽说GC时间变久了，但不会对应用运行造成很大影响。 Android中OOMAndroid应用与Java应用一样，避免OOM就是要剩余足够堆内存供应用使用，要想内存足够呢，首先就需要避免应用存在内存泄漏的情况，内存泄漏后，可使用的内存空间减少，自然就会更容易产生OOM。关于如何避免内存泄漏，可以移步到本人写得另一篇文章《Android中常见的内存泄漏》中。还有一个容易产生OOM的情况，就是加载大数据到内存中。要想更深入理解这一点，让我们来做个简单应用，以下为其核心代码： 1234567891011final List&lt;byte[]&gt; container = new ArrayList&lt;&gt;();findViewById(R.id.get_memory).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Log.e(&quot;pengtao&quot;, &quot;max memory = &quot; + Runtime.getRuntime().maxMemory()); Log.e(&quot;pengtao&quot;, &quot;free memory = &quot; + Runtime.getRuntime().freeMemory()); Log.e(&quot;pengtao&quot;, &quot;total memory = &quot; + Runtime.getRuntime().totalMem byte[] b = new byte[100 * 1000 * 1000]; container.add(b); &#125;&#125;); 同样在这段代码运行在一个堆限制为192M的手机上，当点击两次按钮，应用崩溃，打印的信息如下： 123456712-06 21:17:44.925 4021-4021/? E/pengtao: max memory = 20132659212-06 21:17:44.925 4021-4021/? E/pengtao: free memory = 1676190412-06 21:17:44.925 4021-4021/? E/pengtao: total memory = 13273620812-06 21:17:44.925 4021-4021/? I/art: Starting a blocking GC Alloc12-06 21:17:44.933 4021-4021/? I/art: Alloc sticky concurrent mark sweep GC freed 124(6KB) AllocSpace objects, 0(0B) LOS objects, 12% free, 110MB/126MB, paused 507us total 7.280ms... //省略几次GC日志12-06 21:17:44.988 4021-4021/? W/art: Throwing OutOfMemoryError &quot;Failed to allocate a 100000012 byte allocation with 16777216 free bytes and 81MB until OOM&quot; 该应用崩溃的日志打印为：Throwing OutOfMemoryError &quot;Failed to allocate a 100000012 byte allocation with 16777216 free bytes and 81MB until OOM&quot;，在崩溃前我们可以从日志中看出系统在努力做了几次GC尝试，但却无法释放足够内存，最终只能跑出OOM异常。异常信息反应出奔溃时的内存状况，我们结合到打印的三个数据，和前面我们所讲内容，正好能对上号。126MB即为total memory，free memory为16M，所以使用了110M空间，因堆限制为192M，堆空闲最少需要预留512K，所以还剩81M可用，而这81M空间无法满足下一次的内存分配，所以产生OOM。 图片处理时Android编程中，往往最容易出现OOM的地方就是在图片处理的时候，我们先上个数据：一个像素的显示需要4字节（R、G、B、A各占一个字节），所以一个1080x720像素的手机一个满屏幕画面就需要近3M内存，而开发一个轻量应用的安装包大小也差不多就3M左右，所以说图片很占内存。在Android中，图片的资源文件叫做Drawable，存储在硬盘上，不耗内存，但我们并无法对其进行处理，最多只能进行展示。而如果想对该图片资源进行处理，我们需要把这个Drawable解析为Bitmap形式装载入内存中。其中Android的不同版本对Bitmap的存储方式还有所不同。下面是Android官方文档中对此描述的一段话 On Android 2.3.3 (API level 10) and lower, the backing pixel data for a bitmap is stored in native memory. It is separate from the bitmap itself, which is stored in the Dalvik heap. The pixel data in native memory is not released in a predictable manner, potentially causing an application to briefly exceed its memory limits and crash. As of Android 3.0 (API level 11), the pixel data is stored on the Dalvik heap along with the associated bitmap. bitmap分成两个部分，一部分为bitmap对象，用以存储此图片的长、宽、透明度等信息；另一部分为bitmap数据，用以存储bitmap的(A)RGB字节数据。在2.3.3及以前版本中bitmap对象和bitmap数据是存储在不同的内存空间上的，bitmap数据部分存储在native内存中，GC无法涉及。所以之前我们需要调用bitmap的recycle方法来显示的告诉系统此处内存可回收，而在3.0版本开始，bitmap的的这两部分都存储在了Dalvik堆中，可以被GC机制统一处理，也就无需用recycle了。 关于bitmap优化，不同版本方法也不想同，2.3.3版本及以前，就要做到及时调用recycle来回收不在使用的bitmap，而3.0开始可以使用BitmapFactory.Options.inBitmap这个选项，设置一个可复用的bitmap，这样以后新的bitmap且大小相同的就可以直接使用这块内存，而无需重复申请内存。4.4之后解决了对大小的限制，不同大小也可以复用该块空间。关于inBitmap可参考官方文档。 当有多个bitmap需要显示时，可以使用LruCache算法。实践可以参考一个Github开源库：DaVinci 作者简介彭涛(@彭涛me) 致力于让技术变得易懂且有趣个人博客：http://pengtao.me, GitHub地址：https://github.com/CPPAlien]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android混淆从入门到精通]]></title>
    <url>%2F2016-09-22%2Fproguard-obfuscation%2F</url>
    <content type="text"><![CDATA[简介作为Android开发者，如果你不想开源你的应用，那么在应用发布前，就需要对代码进行混淆处理，从而让我们代码即使被反编译，也难以阅读。混淆概念虽然容易，但很多初学者也只是网上搜一些成型的混淆规则粘贴进自己项目，并没有对混淆有个深入的理解。本篇文章的目的就是让一个初学者在看完后，能在不进行任何帮助的情况下，独立写出适合自己代码的混淆规则。 说在前面这里我们直接用Android Studio来说明如何进行混淆，Android Studio自身集成Java语言的ProGuard作为压缩，优化和混淆工具，配合Gradle构建工具使用很简单，只需要在工程应用目录的gradle文件中设置minifyEnabled为true即可。然后我们就可以到proguard-rules.pro文件中加入我们的混淆规则了。 123456789android &#123; ... buildTypes &#123; release &#123; minifyEnabled true proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; &#125; &#125;&#125; 以上示例代码表示对release版本就行混淆处理。下面我们先来简介下ProGuard的三大作用，并简要说明下它们常用的命令。 ProGuard作用压缩（Shrinking）：默认开启，用以减小应用体积，移除未被使用的类和成员，并且会在优化动作执行之后再次执行（因为优化后可能会再次暴露一些未被使用的类和成员）。 1-dontshrink 关闭压缩 优化（Optimization）：默认开启，在字节码级别执行优化，让应用运行的更快。 12-dontoptimize 关闭优化-optimizationpasses n 表示proguard对代码进行迭代优化的次数，Android一般为5 混淆（Obfuscation）：默认开启，增大反编译难度，类和类成员会被随机命名，除非用keep保护。1-dontobfuscate 关闭混淆 混淆后默认会在工程目录app/build/outputs/mapping/release下生成一个mapping.txt文件，这就是混淆规则，我们可以根据这个文件把混淆后的代码反推回源本的代码，所以这个文件很重要，注意保护好。原则上，代码混淆后越乱越无规律越好，但有些地方我们是要避免混淆的，否则程序运行就会出错，所以就有了下面我们要教大家的，如何让自己的部分代码避免混淆从而防止出错。 基本规则先看如下两个比较常用的命令，很多童鞋可能会比较迷惑以下两者的区别。 12-keep class cn.hadcn.test.**-keep class cn.hadcn.test.* 一颗星表示只是保持该包下的类名，而子包下的类名还是会被混淆；两颗星表示把本包和所含子包下的类名都保持；用以上方法保持类后，你会发现类名虽然未混淆，但里面的具体方法和变量命名还是变了，这时如果既想保持类名，又想保持里面的内容不被混淆，我们就需要以下方法了 -keep class cn.hadcn.test.* {*;} 在此基础上，我们也可以使用Java的基本规则来保护特定类不被混淆，比如我们可以用extend，implement等这些Java规则。如下例子就避免所有继承Activity的类被混淆 -keep public class * extends android.app.Activity 如果我们要保留一个类中的内部类不被混淆则需要用$符号，如下例子表示保持ScriptFragment内部类JavaScriptInterface中的所有public内容不被混淆。 123-keepclassmembers class cc.ninty.chat.ui.fragment.ScriptFragment$JavaScriptInterface &#123; public *;&#125; 再者，如果一个类中你不希望保持全部内容不被混淆，而只是希望保护类下的特定内容，就可以使用 123&lt;init&gt;; //匹配所有构造器&lt;fields&gt;; //匹配所有域&lt;methods&gt;; //匹配所有方法方法 你还可以在&lt;fields&gt;或&lt;methods&gt;前面加上private 、public、native等来进一步指定不被混淆的内容，如 123-keep class cn.hadcn.test.One &#123; public &lt;methods&gt;;&#125; 表示One类下的所有public方法都不会被混淆，当然你还可以加入参数，比如以下表示用JSONObject作为入参的构造函数不会被混淆 123-keep class cn.hadcn.test.One &#123; public &lt;init&gt;(org.json.JSONObject);&#125; 有时候你是不是还想着，我不需要保持类名，我只需要把该类下的特定方法保持不被混淆就好，那你就不能用keep方法了，keep方法会保持类名，而需要用keepclassmembers ，如此类名就不会被保持，为了便于对这些规则进行理解，官网给出了以下表格 保留 防止被移除或者被重命名 防止被重命名 类和类成员 -keep -keepnames 仅类成员 -keepclassmembers -keepclassmembernames 如果拥有某成员，保留类和类成员 -keepclasseswithmembers -keepclasseswithmembernames 移除是指在压缩(Shrinking)时是否会被删除。以上内容时混淆规则中需要重点掌握的，了解后，基本所有的混淆规则文件你应该都能看懂了。再配合以下几点注意事项，开启你为自己代码，实现混淆规则之旅吧。 注意事项1，jni方法不可混淆，因为这个方法需要和native方法保持一致； 123-keepclasseswithmembernames class * &#123; # 保持native方法不被混淆 native &lt;methods&gt;;&#125; 2，反射用到的类不混淆(否则反射可能出现问题)； 3，AndroidMainfest中的类不混淆，所以四大组件和Application的子类和Framework层下所有的类默认不会进行混淆。自定义的View默认也不会被混淆；所以像网上贴的很多排除自定义View，或四大组件被混淆的规则在Android Studio中是无需加入的； 4，与服务端交互时，使用GSON、fastjson等框架解析服务端数据时，所写的JSON对象类不混淆，否则无法将JSON解析成对应的对象； 5，使用第三方开源库或者引用其他第三方的SDK包时，如果有特别要求，也需要在混淆文件中加入对应的混淆规则； 6，有用到WebView的JS调用也需要保证写的接口方法不混淆，原因和第一条一样； 7，Parcelable的子类和Creator静态成员变量不混淆，否则会产生Android.os.BadParcelableException异常； 123-keep class * implements Android.os.Parcelable &#123; # 保持Parcelable不被混淆 public static final Android.os.Parcelable$Creator *;&#125; 8，使用enum类型时需要注意避免以下两个方法混淆，因为enum类的特殊性，以下两个方法会被反射调用，见第二条规则。 1234-keepclassmembers enum * &#123; public static **[] values(); public static ** valueOf(java.lang.String); &#125; 写在最后发布一款应用除了设minifyEnabled为ture，你也应该设置zipAlignEnabled为true，像Google Play强制要求开发者上传的应用必须是经过zipAlign的，zipAlign可以让安装包中的资源按4字节对齐，这样可以减少应用在运行时的内存消耗。 作者简介彭涛(@彭涛me) 致力于让技术变得易懂且有趣个人博客：http://pengtao.me, GitHub地址：https://github.com/CPPAlien]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>混淆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Attr、Style和Theme详解]]></title>
    <url>%2F2016-05-11%2Fattr-style-theme%2F</url>
    <content type="text"><![CDATA[前言这三个概念贯穿Android框架的方方面面，是Android程序设计中很重要的一环，理解它们，并能学以致用，不但可以让你的代码变得简洁明了，还可以让你的应用更加灵活。但目前网上资料对这块介绍的知识点往往比较散，不是很系统全面，在此特以自己开发经验总结此文一篇，希望可以帮助初学者把这三个概念彻底搞明白，开发出高质量的Android代码。 概念说明Attr：属性，风格样式的最小单元； Style：风格，它是一系列Attr的集合用以定义一个View的样式，比如height、width、padding等； Theme：主题，它与Style作用一样，不同于Style作用于个一个单独View，而它是作用于Activity上或是整个应用。 Attr的定义我们先举一个框架中的源码例子，用来介绍下Android中是如何定义一个Attr的，比如以下创建一个简单的TextView布局其中layout_width对应到框架中的attr信息如下：12345678&lt;declare-styleable name=&quot;ViewGroup_Layout&quot;&gt; &lt;attr name=&quot;layout_width&quot; format=&quot;dimension&quot;&gt; &lt;enum name=&quot;fill_parent&quot; value=&quot;-1&quot; /&gt; &lt;enum name=&quot;match_parent&quot; value=&quot;-1&quot; /&gt; &lt;enum name=&quot;wrap_content&quot; value=&quot;-2&quot; /&gt; &lt;/attr&gt; ...&lt;/declare-styleable&gt; 从上可以看到layout_width可以使用三个枚举值，并且其中fill_parent和match_parent的value值都为-1。做过Android开发的童鞋肯定知道，从2.2开始Android框架就推荐用match_parent代替fill_parent，而以上代码正实现了兼容，因为它们对应的值都为-1。 以上的textStyle的属性信息在源码中如下： 12345&lt;attr name=&quot;textStyle&quot;&gt; &lt;flag name=&quot;normal&quot; value=&quot;0&quot; /&gt; &lt;flag name=&quot;bold&quot; value=&quot;1&quot; /&gt; &lt;flag name=&quot;italic&quot; value=&quot;2&quot; /&gt;&lt;/attr&gt; 它也对应了三个值，但这里却使用了flag标签。细心的童鞋可能已经明白了flag与enum的差别，flag表示这几个值可以做或运算，比如上面的textStyle，你可以叠加使用，如用bold|italic表示既加粗也变成斜体，而enum只能让你选择其中一个值。 看完上例后，我们来试着自己自定义一个自己的属性，在values目录下创建一个attrs.xml文件，在&lt;resources&gt;元素里面首先申明一个自己的&lt;declare-styleable&gt;表示一个属性组，再在里面加上属性就行。如下我们定义一个DogStyle的属性组，其中有三个属性一个是dogSex，一个是dogName，dogName的格式我们设置为string，最后一个是dogColor，这样一个属于我们自己的属性就定义成功了。 attr的format根据字面意思也挺容易理解的，这里我解释下reference的用法。它用在一些可以设置引用值的情况，比如@drawable/myImage、@color/myColor等。当然format也可以进行或运算，一般我们定义color类型的属性时，也一般会把format写成format=&quot;reference|color&quot;，这样我们不但可以设置颜色值，如#FFFFFF，还可以使用我们自己定义的狗图片，如@drawable/dog_pic。 TIPS：format即使用错，只要你自定义的View中获取对应类型值也是可以的，只是在布局中写代码时，IDE就不会根据你定义的format给出相应的提示了，所以最好在自定义View时还是仔细斟酌下类型。 Style的使用如下我们在styles.xml中定义一个雪纳瑞风格12345&lt;style name=&quot;SchnauzerStyle&quot;&gt; &lt;item name=&quot;dogName&quot;&gt;雪纳瑞&lt;/item&gt; &lt;item name=&quot;dogColor&quot;&gt;@drawable/schnauzer&lt;/item&gt; &lt;item name=&quot;dogSex&quot;&gt;boy&lt;/item&gt;&lt;/style&gt; 下面我们看下如何让一个Style作用在一个View上的。首先我们自定义了一个View命名为DogView，然后创建一个布局文件中加入该DogView视图，并让该View使用SchnauzerStyle风格。代码如下：1234&lt;cn.hadcn.test.DogView style=&quot;@style/SchnauzerStyle&quot; android:layout_height=&quot;wrap_content&quot; android:layout_width=&quot;wrap_content&quot;/&gt; 移步到DogView的Java代码中，我们可以通过theme的obtainStyledAttributes方法来获得我们刚刚定义的几个Attr属性在Style中的内容，如下我们举一个获得dogName的例子：1234567final Resources.Theme theme = context.getTheme();TypedArray dogArray = theme.obtainStyledAttributes(attrs, R.styleable.DogStyle, defStyleAttr, defStyleRes);String name = dogArray.getString(R.styleable.DogStyle_dogName);Log.e(&quot;dog&quot;, &quot;name = &quot; + name);dogArray.recycle(); 以上obtainStyledAttributes有四个入参，前两个比较容易理解，后两个用作指定默认的Style，表示如果attrs中没有你想获得的属性，但如果你指定了默认Style，它会去从该默认的Style里面找你想要的属性。defStyleAttr和defStyleRes功能一样，指定的资源形式不同，前者表示一个默认的指向一个style风格的attr属性，而后者你可以直接传入一个style风格的id。注意以上定义的Style只能在这个DogView中被使用，如果你想在其他View使用，就需要再在需要使用的View中增加这个Style。这就是先前我们说的Style只能作用于一个View。 Theme的使用Theme与Style使用同一个元素标签&lt;style&gt;，区别在于所包含的属性不同，并且使用的地方也不一样。Theme你需要设置到AndroidManifest.xml的&lt;application&gt;或者&lt;activity&gt;标签下，设置后，被设置的Activity或整个应用下所有的View都可以使用该&lt;style&gt;里面的属性了。 比如在上例中，我们直接把SchnauzerStyle设置到&lt;activity&gt;标签中，并把布局文件中DogView元素的style=&quot;@style/SchnauzerStyle&quot;栏位删除，以此来测试下，这个Activity下的所有View是不是可以直接使用theme中声明的这些属性。1234&lt;activity android:name=&quot;.MainActivity&quot; android:theme=&quot;@style/SchnauzerStyle&quot;&gt; ... 以上理论上是可行的，不过运行后，程序却出现奔溃，出现以下错误提示：1java.lang.IllegalStateException: You need to use a Theme.AppCompat theme (or descendant) with this activity. 有些同学一眼可能就看出，因为在这里Activity或Application的需要很多属性才能工作的，而此处我们只给它传一个SchnauzerStyle，这当然不行，所以我们需要对这个Style做下处理，让SchnauzerStyle继承一个系统主题，如下：12345&lt;style name=&quot;SchnauzerStyle&quot; parent=&quot;Theme.AppCompat&quot;&gt; &lt;item name=&quot;dogName&quot;&gt;雪纳瑞&lt;/item&gt; &lt;item name=&quot;dogColor&quot;&gt;@drawable/schnauzer&lt;/item&gt; &lt;item name=&quot;dogSex&quot;&gt;boy&lt;/item&gt;&lt;/style&gt; 这样一个雪纳瑞主题就诞生了，而在这个Activity下的所有View都可以用雪纳瑞的信息了。Application中定义theme的原理一样，这里就不多说了。 TIPS：框架使用Attr的顺序是：View中的Style会优先于Activity中的Theme，Activity中的Theme会优先于Application中的Theme，所以说你可以定义整个应用的总体风格，但局部风格你也可以做出自己的调整。 Attr的获得方法有些情况下，我们可能需要使用theme中的属性值，比如下面我们想让一个TextView直接显示dogName这个属性的内容，并且使用系统字体的颜色，则可以如下做：12345&lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:textColor=&quot;?android:textColorSecondary&quot; android:text=&quot;?attr/dogName&quot;/&gt; 获得一个Attr的方法，不同于普通资源使用@符号获得的方式，而是需要使用?符号来获得属性，整体的表达方式如下：1?[*&lt;package_name&gt;*:][*&lt;resource_type&gt;*/]*&lt;resource_name&gt;* 如果是本应用中的attr使用，则可以省去&lt;package_name&gt;部分。 此处的textColor使用当前主题的android:textColorSecondary属性内容。因为资源工具知道此处是一个属性，所以省去了attr （完整写法：?android:attr/textColorSecondary）。 总结我刚开始学Android的时候，也总对这三个概念很迷惑，不知道什么是属性，什么是风格，什么是主题，它们之间又有什么关系？它们在Android框架中又充当什么角色？又如何自己去定义？但随着学习的深入，越发觉得这三块内容真是Android框架的一大神器，有时你不用改动代码，只要换一个theme，应用马上焕发青春。而且也尝试用所学内容去写自己的theme，不但可以让自己的布局文件更加清晰明了，而且还让自己的代码具有更高的扩展性，真是好处多多，希望对这块还不了解的童鞋多多研习。 作者简介彭涛(@彭涛me) 致力于让技术变得易懂且有趣个人博客：http://pengtao.me, GitHub地址：https://github.com/CPPAlien]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>资源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ContentProvider从入门到精通]]></title>
    <url>%2F2016-05-02%2FContentProvider%2F</url>
    <content type="text"><![CDATA[前言ContentProvider虽然与Activity、Service、BroadcastReceiver齐名为Android四大组件。但如果你不是特别开发一款与其他APP有数据交互的应用，它的使用频率远没有另外三者高。进而有些开发者可能在做过几个成熟应用后，对ContentProvider的理解还是不够深入，无法独立完成ContentProvider功能的开发。网上博客对这一块的内容介绍的也是比较复杂，不适合初学者研究学习，此篇希望能全面介绍下ContentProvider，从ContentProvider在框架中所充当的角色，到ContentResolver的使用，到URI的概念，再到数据共享的方法和权限管理，一步步的让大家对ContentProvider有个全面的认识。 ContentProvider的角色ContentProvider一般为存储和获取数据提供统一的接口，可以在不同的应用程序之间共享数据。 之所以使用ContentProvider，主要有以下几个理由：1，ContentProvider提供了对底层数据存储方式的抽象。比如下图中，底层使用了SQLite数据库，在用了ContentProvider封装后，即使你把数据库换成MongoDB，也不会对上层数据使用层代码产生影响。 2，Android框架中的一些类需要ContentProvider类型数据。如果你想让你的数据可以使用在如SyncAdapter, Loader, CursorAdapter等类上，那么你就需要为你的数据做一层ContentProvider封装。 3，第三个原因也是最主要的原因，是ContentProvider为应用间的数据交互提供了一个安全的环境。它准许你把自己的应用数据根据需求开放给其他应用进行增、删、改、查，而不用担心直接开放数据库权限而带来的安全问题。 我们知道了ContentProvider是对数据层的封装后，那么大家可能会问我们要如何对ContentProvider进行增，删，改，查的操作呢？下面我们来介绍一个新的类ContentResolver，我们可以通过它，来对不同的ContentProvider进行操作。 ContentResolver有些人可能会疑惑，为什么我们不直接访问Provider，而是又在上面加了一层ContentResolver来进行对其的操作，这样岂不是更复杂了吗？其实不然，大家要知道一台手机中可不是只有一个Provider内容，它可能安装了很多含有Provider的应用，比如联系人应用，日历应用，字典应用等等。有如此多的Provider，如果你开发一款应用要使用其中多个，如果让你去了解每个ContentProvider的不同实现，岂不是要头都大了。所以Android为我们提供了ContentResolver来统一管理与不同ContentProvider间的操作。 在Context.java的源码中有一段12/** Return a ContentResolver instance for your application&apos;s package. */ public abstract ContentResolver getContentResolver(); 所以我们可以通过在所有继承Context的类中通过调用getContentResolver()来获得ContentResolver。 可能又有童鞋会问，那ContentResolver是如何来区别不同的ContentProvider的呢？这就涉及到URI（Uniform Resource Identifier）问题，对URI是什么还不明白的童鞋请自行Google。 ContentProvider中的URIContentProvider中的URI有固定格式，如下图： Authority：授权信息，用以区别不同的ContentProvider；Path：表名，用以区分ContentProvider中不同的数据表；Id：Id号，用以区别表中的不同数据； URI组装代码示例：123456789101112131415161718public class TestContract &#123; protected static final String CONTENT_AUTHORITY = &quot;me.pengtao.contentprovidertest&quot;; protected static final Uri BASE_CONTENT_URI = Uri.parse(&quot;content://&quot; + CONTENT_AUTHORITY); protected static final String PATH_TEST = &quot;test&quot;; public static final class TestEntry implements BaseColumns &#123; public static final Uri CONTENT_URI = BASE_CONTENT_URI.buildUpon().appendPath(PATH_TEST).build(); protected static Uri buildUri(long id) &#123; return ContentUris.withAppendedId(CONTENT_URI, id); &#125; protected static final String TABLE_NAME = &quot;test&quot;; public static final String COLUMN_NAME = &quot;name&quot;; &#125;&#125; 从上面代码我们可以看到，我们创建了一个content://me.pengtao.contentprovidertest/test的uri，并且开了一个静态方法，用以在有新数据产生时根据id生成新的uri。下面介绍下如何把此uri映射到数据库表中。 实作首先我们创建一个自己的TestProvider继承ContentProvider。默认该Provider需要实现如下六个方法，onCreate(), query(Uri, String[], String, String[], String),insert(Uri, ContentValues), update(Uri, ContentValues, String, String[]), delete(Uri, String, String[]), getType(Uri)，方法的具体介绍可以参考http://developer.android.com/reference/android/content/ContentProvider.html 下面我们以实现insert和query方法为例123456789101112131415161718192021222324252627282930313233343536373839404142434445private final static int TEST = 100;static UriMatcher buildUriMatcher() &#123; final UriMatcher matcher = new UriMatcher(UriMatcher.NO_MATCH); final String authority = TestContract.CONTENT_AUTHORITY; matcher.addURI(authority, TestContract.PATH_TEST, TEST); return matcher;&#125;@Nullable@Overridepublic Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) &#123; final SQLiteDatabase db = mOpenHelper.getReadableDatabase(); Cursor cursor = null; switch ( buildUriMatcher().match(uri)) &#123; case TEST: cursor = db.query(TestContract.TestEntry.TABLE_NAME, projection, selection, selectionArgs, sortOrder, null, null); break; &#125; return cursor;&#125;@Nullable@Overridepublic Uri insert(Uri uri, ContentValues values) &#123; final SQLiteDatabase db = mOpenHelper.getWritableDatabase(); Uri returnUri; long _id; switch ( buildUriMatcher().match(uri)) &#123; case TEST: _id = db.insert(TestContract.TestEntry.TABLE_NAME, null, values); if ( _id &gt; 0 ) returnUri = TestContract.TestEntry.buildUri(_id); else throw new android.database.SQLException(&quot;Failed to insert row into &quot; + uri); break; default: throw new android.database.SQLException(&quot;Unknown uri: &quot; + uri); &#125; return returnUri;&#125; 此例中我们可以看到，我们根据path的不同，来区别对不同的数据库表进行操作，从而完成uri与具体数据库间的映射关系。 因为ContentProvider作为四大组件之一，所以还需要在AndroidManifest.xml中注册一下。123&lt;provider android:authorities=&quot;me.pengtao.contentprovidertest&quot; android:name=&quot;.provider.TestProvider&quot; /&gt; 然后你就可以使用getContentResolver()方法来对该ContentProvider进行操作了，ContentResolver对应ContentProvider也有insert，query，delete等方法，详情请参考：http://developer.android.com/reference/android/content/ContentResolver.html 此处因为我们只实现了ContentProvider的query和insert的方法，所以我们可以进行插入和查询处理。如下我们可以在某个Activity中进行如下操作，先插入一个数据peng，然后再从从表中读取第一行数据中的第二个字段的值。 1234567891011121314ContentValues contentValues = new ContentValues();contentValues.put(TestContract.TestEntry.COLUMN_NAME, &quot;peng&quot;);contentValues.put(TestContract.TestEntry._ID, System.currentTimeMillis());getContentResolver().insert(TestContract.TestEntry.CONTENT_URI, contentValues);Cursor cursor = getContentResolver().query(TestContract.TestEntry.CONTENT_URI, null, null, null, null);try &#123; Log.e(&quot;ContentProviderTest&quot;, &quot;total data number = &quot; + cursor.getCount()); cursor.moveToFirst(); Log.e(&quot;ContentProviderTest&quot;, &quot;total data number = &quot; + cursor.getString(1));&#125; finally &#123; cursor.close();&#125; 数据共享以上例子中创建的ContentProvider只能在本应用内访问，那如何让其他应用也可以访问此应用中的数据呢，一种方法是向此应用设置一个android:sharedUserId，然后需要访问此数据的应用也设置同一个sharedUserId，具有同样的sharedUserId的应用间可以共享数据。 但此种方法不够安全，也无法做到对不同数据进行不同读写权限的管理，下面我们就来详细介绍下ContentProvider中的数据共享规则。 首先我们先介绍下，共享数据所涉及到的几个重要标签：android:exported 设置此provider是否可以被其他应用使用。android:readPermission 该provider的读权限的标识android:writePermission 该provider的写权限标识android:permission provider读写权限标识android:grantUriPermissions 临时权限标识，true时，意味着该provider下所有数据均可被临时使用；false时，则反之，但可以通过设置&lt;grant-uri-permission&gt;标签来指定哪些路径可以被临时使用。这么说可能还是不容易理解，我们举个例子，比如你开发了一个邮箱应用，其中含有附件需要第三方应用打开，但第三方应用又没有向你申请该附件的读权限，但如果你设置了此标签，则可以在start第三方应用时，传入FLAG_GRANT_READ_URI_PERMISSION或FLAG_GRANT_WRITE_URI_PERMISSION来让第三方应用临时具有读写该数据的权限。 知道了这些标签用法后，让我们改写下AndroidManifest.xml，让ContentProvider可以被其他应用查询。 声明一个permission1&lt;permission android:name=&quot;me.pengtao.READ&quot; android:protectionLevel=&quot;normal&quot;/&gt; 然后改变provider标签为123456&lt;provider android:authorities=&quot;me.pengtao.contentprovidertest&quot; android:name=&quot;.provider.TestProvider&quot; android:readPermission=&quot;me.pengtao.READ&quot; android:exported=&quot;true&quot;&gt;&lt;/provider&gt; 则在其他应用中可以使用以下权限来对TestProvider进行访问。1&lt;uses-permission android:name=&quot;me.pengtao.READ&quot;/&gt; 有人可能又想问，如果我的provider里面包含了不同的数据表，我希望对不同的数据表有不同的权限操作，要如何做呢？Android为这种场景提供了provider的子标签&lt;path-permission&gt;，path-permission包括了以下几个标签。123456&lt;path-permission android:path=&quot;string&quot; android:pathPrefix=&quot;string&quot; android:pathPattern=&quot;string&quot; android:permission=&quot;string&quot; android:readPermission=&quot;string&quot; android:writePermission=&quot;string&quot; /&gt; 可以对不同path设置不同的权限规则，具体如何设定我这里就不做详细介绍了，可以参考http://developer.android.com/guide/topics/manifest/path-permission-element.html 相关代码ContentProviderTesthttps://github.com/CPPAlien/ContentProviderTest ContentResolverTesthttps://github.com/CPPAlien/ContentResolverTest 注：ContentResolverTest是读取ContentProviderTest中的数据来显示，所以需要先安装ContentProviderTest。 作者简介彭涛(@彭涛me) 致力于让技术变得易懂且有趣个人博客：http://pengtao.me, GitHub地址：https://github.com/CPPAlien]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ContentProvider</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android中常见的内存泄漏]]></title>
    <url>%2F2016-04-18%2Fmemory-leak%2F</url>
    <content type="text"><![CDATA[写在前面虽然现在手机的内存不断增大，但Android为了实现不同应用间运行隔离，不至于相互影响，所以对单个应用最大可使用的内存做出了限制。限制大小在不同手机设备和ROM上都可能不一样。如Android界的第一款手机HTC G1是16MB，后来的Nexus One是32MB。所以即使手机内存不断变大，但你开发的应用可使用的内存空间并没有增大很多，这也需要你开发时多注意注意内存问题，遵从最少使用内存的原则，避免内存泄漏的发生，这样不但能让你的应用避免被系统无故杀死，还能让用户使用更加流畅。 如果想查看自己应用可以使用的最大内存空间，可以参考：《Detect application heap size in Android》如果你实在需要增大自己应用的内存使用大小，可以参考这篇文章：《How to increase heap size of an android application》 内存泄漏的产生Android的虚拟机机制模仿JVM，所以也有垃圾回收机制。Android虚拟机中把内存分为两部分，一部分为栈空间，存储一些全局引用和静态变量等值，该空间的分配与回收由系统机制决定，垃圾回收不作用在这块区域；另一部分为堆空间，里面存储是对象的实例，需要开发者主动创建，垃圾回收主要作用在这部分，回收的一个主要策略是检测堆中的对象在栈空间有无对应的引用。如果没有引用指向它，则会被优先回收，如果有引用指向则不会被回收。所以如果开发者没有在适当的时间把一个对象的引用设置为null，则就会可能会产生内存泄漏。在Android中最常见的一个内存泄漏问题就是长时间持有Context。Context在Android中有非常大的作用，比如用来获取资源，所以基本上所有的视图都需要获得Context才能被创建。使用不当则很可能造成内存泄漏。 Android中内存泄漏表现你开发了一个应用，刚开始使用起来还挺流畅，但随着使用时间变长，应用就变得越来越慢，最后导致用户不得重启应用才能继续使用。这就很可能出现了内存泄漏。就像上面提到的，如果说一个静态变量持有了一个Activity的引用，用户打开该Activity，会创建一个Activity的实例，此时即使你关闭该Activity，虽然它不再显示，但它的实例一直会在内存中存在，因为有一个静态变量一直指向它，导致它的内存空间就不会被当做垃圾回收。想想这个Activity中可能包含很多属性，很多视图的信息，它未被释放，会浪费很多内存空间。下面我们从两个个例子入手，讲解下内存泄漏和解决办法。 一个例子12345678910111213141516private static Drawable sBackground;@Overrideprotected void onCreate(Bundle state) &#123; super.onCreate(state); TextView label = new TextView(this); label.setText(&quot;Leaks are bad&quot;); if (sBackground == null) &#123; sBackground = getDrawable(R.drawable.large_bitmap); &#125; label.setBackgroundDrawable(sBackground); setContentView(label);&#125; 以上使用一个静态变量来保存一个drawable。从上分析可以看到，一个TextView的局部变量持有了本Activity的引用，因为label是局部变量，所以并不会引起内存泄漏。但紧接着下面，使用了label.setBackgroundDrawable(sBackground); 有人可能就会想，这也没啥问题啊，即使sBackground作为一个静态变量，持有了一个drawable，这块内存不会被释放，但这块内存毕竟没有持有整个Activity的引用。但实际上你错了。我们来看下View.java中的setBackgroundDrawable源码，源码位置在（frameworks/base/core/java/android/view/View.java）1234567891011121314public void setBackgroundDrawable(Drawable background) &#123; ... if (background != null) &#123; ... background.setCallback(this); ... &#125; else &#123; ... &#125; ...&#125; 其中有一个background.setCallback(this);，所以这就导致这个静态变量指向的对象又持有了TextView这个对象的引用。这样，因为是静态变量，像我上一小节所说的，静态变量的生命周期基本和应用同周期，它持有了TextView对象引用，所以TextView不会被回收，然后TextView又持有了整个Activity的引用，所以最后就导致整个Activity在关闭后也不会被系统回收。 当然解决此种问题的方法非常简单，就是把sBackground换成非静态变量就行，这样当Activity关闭后，回收机制就能判断，这个Activity的空间不会被使用到了，所以就启动GC。 另一个例子下面我们再举一个非常常见的例子，Android开发者很喜欢用单例模式，但有些开发者不注意就可能导致内存泄漏，如下： 12345678private static DaVinci sDaVinci = null;public static DaVinci with(Context context) &#123; if ( sDaVinci == null ) &#123; sDaVinci = new DaVinci(context); &#125; return sDaVinci;&#125; 大家可能一时觉得这没啥问题啊，但这并不是一个好的写法，因为这可能让用户在使用时把一个Activity的Context传入，导致让一个单例持有了这个Activity的Context引用，造成内存泄漏。一个比较好的写法是使用sDaVinci = new DaVinci(context.getApplicationContext());。因为Application的生命周期本来就是贯穿整个应用的，所以即使被持有也没关系。 几点建议1，尽量不要用一个生命周期长于Activity的对象来持有Activity的引用。2，在需要传入Context的时候尽量考虑使用Application的Context，而不是Activity的。3，在Activity中尽量避免使用生命周期不受控制的非静态类型的内部类，可以使用静态类型的内部类加上弱引用的方式实现。 作者简介彭涛(@彭涛me) 致力于让技术变得易懂且有趣个人博客：http://pengtao.me, GitHub地址：https://github.com/CPPAlien]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你真的会用Android中Strings资源吗]]></title>
    <url>%2F2016-02-29%2Fuse-strings%2F</url>
    <content type="text"><![CDATA[Android为了帮助开发者把应用更方便发布给全球不同语言的人们使用，建议开发者在进行开发时不要把UI呈现相关的文本内容硬编码，而是把内容写入到strings.xml中，这样做更加灵活，也更方便翻译成不同其他语言。下面通过一个案例来逐步介绍一下strings的用法。 基本用法比如我想在我的应用页面上呈现一句话，叫“我想买一台Kindle”，那就可以在strings.xml中加入如下：1&lt;string name=&quot;buy_kindle&quot;&gt;我想买一台Kindle&lt;/string&gt; 在需要使用该字符串的地方通过getString获得后使用。1getString(R.string.buy_kindle) 添加参数现在你觉得这句话把买Kindle的数量写死了，因为你在代码中不同地方都用到了这句话，但所买的Kindle数量不一样。strings资源让开发者可以自主在字符串的任何位置加上参数，比如要解决这个问题，可以：12&lt;string name=&quot;one&quot;&gt;一&lt;/string&gt;&lt;string name=&quot;buy_kindle&quot;&gt;我想买%s台Kindle&lt;/string&gt; 在有参数的情况下可以通过如下方式传入1getString(R.string.buy_kindle, getString(R.string.one)) 如果你想在这句话中加入多个参数，比如想说：“我想买一台Kindle送给小明”，而送给谁可以自定，则可以如下表达。12&lt;string name=&quot;buy_kindle&quot;&gt;我想买%1$s台Kindle送给%2$s&lt;/string&gt;getString(R.string.buy_kindle, getString(R.string.one), getString(R.string.xiaoming)) 注意在多个参数时，需要给参数加入位置信息，如上的%1$s。后面加上的参数会根据位置信息对应入号。具体做法如Java中的formatter方法一样，请参考：http://developer.android.com/reference/java/util/Formatter.html 国际化比如想把这句话翻译成英文，你可以新创建一个英文的Values resource file，如下图方式选择：翻译成如下：1&lt;string name=&quot;buy_kindle&quot;&gt;I want to buy %1$s Kindle&lt;/string&gt; 从中可以发现Kindle这个词并没有翻译，Android中对无需翻译的词，我们可以用标签来标注起来，这样我们把资源文件给他人或者使用Google Play自动翻译服务时，对方就知道该部分无需翻译。如下：12&lt;resources xmlns:xliff=&quot;urn:oasis:names:tc:xliff:document:1.2&quot;&gt;&lt;string name=&quot;buy_kindle&quot;&gt;我想买%s台&lt;xliff:g id=&quot;Kindle&quot;&gt;Kindle&lt;/xliff:g&gt;&lt;/string&gt; 注意使用该标签时，先在资源之前加上命名空间：xmlns:xliff=”urn:oasis:names:tc:xliff:document:1.2”。 TIPS：Google play控制台提供APP TRANSLATION SERVICE的翻译服务 带数量判定的字符串在翻译成英语后，发现问题来了，如果我想表示买了多台Kindle，但在英语语法中多台Kindle需要用复数形式Kindles，这要如何做呢？Android为这种情形提供了Plurals方法。1234&lt;plurals name=&quot;buy_kindle&quot;&gt; &lt;item quantity=&quot;one&quot;&gt;I want to buy a Kindle&lt;/item&gt; &lt;item quantity=&quot;other&quot;&gt;I want to buy some Kindles&lt;/item&gt;&lt;/plurals&gt; 获得该plurals方法如下，第二参数传入quantity，系统会根据quantity来选择对应的显示，该方法后也可以加入参数：1getResources().getQuantityString(R.plurals.buy_kindle, 2) 中文部分可以改成：1234&lt;plurals name=&quot;buy_kindle&quot;&gt; &lt;item quantity=&quot;one&quot;&gt;我想买一台&lt;xliff:g id=&quot;Kindle&quot;&gt;Kindle&lt;/xliff:g&gt;&lt;/item&gt; &lt;item quantity=&quot;other&quot;&gt;我想买几台&lt;xliff:g id=&quot;Kindle&quot;&gt;Kindle&lt;/xliff:g&gt;&lt;/item&gt;&lt;/plurals&gt; TIPS：关于Quantity String的更详细说明请移步：http://developer.android.com/guide/topics/resources/string-resource.html#Plurals 加入特殊字符有些字符是没有办法在strings.xml里面直接写的，比如”&lt;”，”&gt;”，但可以用它对应的ASCII码来替代进行显示，比如要表达：我想买一台Kindle&lt;$100&gt;，则可以：1&lt;item quantity=&quot;one&quot;&gt;我想买一台&lt;xliff:g id=&quot;Kindle&quot;&gt;Kindle&lt;$100&gt;&lt;/xliff:g&gt;&lt;/item&gt; 其中“&lt;”的ASCII是&amp;#060，“&gt;”的是&amp;#062。更多特殊字符与ASCII对应表可以查看：《常见字符与ASCII十进制对应表》 作者简介彭涛(@彭涛me) 致力于让技术变得简单而有趣个人博客：http://pengtao.me, GitHub地址：https://github.com/CPPAlien]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>资源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android端实现Cookie机制]]></title>
    <url>%2F2016-02-19%2Fandroid-cookie%2F</url>
    <content type="text"><![CDATA[简介Session是服务端验证客户端身份的一种机制。而Cookie是客户端存储的一种身份凭证，由服务端在回应的消息头中通过Set-Cookie字段“种”在客户端。以后每次客户端在向服务端请求时都会在消息头中带上Cookie字段。服务端就会根据Cookie的来判断此次请求是从哪个用户发过来的，是否是一次有效请求等。有关Cookie的标准定义可以参考 RFC6265。以下我们稍做介绍。 举个例子首次打开浏览器请求http://www.baidu.com ，我们会得到一个response消息头如下格式。可以看到里面包含了多条Set-Cookie，Cookie是key-value形式的。每条Cookie都有一个效信息字段，有些还含有expires、domain和path等字段。其中的domain和path字段，区分了不同的cookie可以被哪些网页链接获得，如未设置domain，则使用当前的访问链接替代。比如上面的BD_HOME=0，我们在下表[本地cookie信息]中，一样可以看到它的domain为www.baidu.com，这是因为我们访问的就是这个地址。其中的expires和max-age定义了该Cookie的有效期，失效的Cookie在下次请求时不会被加入到Cookie头中。 请求后我们查看浏览器的Cookie表，可以看到这些Cookie信息被“种”下了。此时再发送一条请求，可以看到请求的消息头如下： 不同网站的请求，会因为请求链接的不同，只能从浏览器取得属于自己的cookie，根据上文提到的domain和path字段来区分。关于匹配的详细规则还是可以查看RFC6265。这边我们用domain的匹配来稍微说下，在标准的5.1.3条目是有关domain matching的。123456789101112131415A string domain-matches a given domain string if at least one of the following conditions hold: o The domain string and the string are identical. (Note that both the domain string and the string will have been canonicalized to lower case at this point.) o All of the following conditions hold: * The domain string is a suffix of the string. * The last character of the string that is not included in the domain string is a %x2E (&quot;.&quot;) character. * The string is a host name (i.e., not an IP address). 从中我们可以看出domain要满足两点才能算是匹配，第一点，完全相同；如果第一点不满足则需要，请求链接的后缀包含存储的cookie的domain，并且不包含部分的最后一个字符还得是”.”，并且还是是个域名，而非IP地址。domain匹配成功后，还要匹配path，path的匹配要比domain复杂一些，具体可以查看标准的5.1.4。path匹配可以做到一个网站下的页面可以分别存储不同的cookie，也可以共享上层父页面的cookie，比较灵活。 客户端实现Android自身所带的HttpUrlConnection方法是默认不开启Cookie存储的。不过我们可以用java提供的几个类来在Android中实现：可以先在所有请求之前声明1CookieHandler.setDefault(new CookieManager(null, CookiePolicy.ACCEPT_ALL)); 开启此开关后，每次请求的Set-Cookie信息都会被CookieManager处理。CookieManager又会使用第一个参数传入的CookieStore来处理Cookie的存储问题，因为此处传入了null，系统会默认调用一个基于CookieStore实现的CookieStoreImpl类来处理Cookie的存储，这个类的只有基于内存的存储，当进程被杀死后，下次再进入应用，保存的Cookie信息就会丢失。所以我们需要基于CookieStore这个接口实现一个具有内存和本地双存储机制的Cookie存储类。 可以参考：Fran Montiel实现的PersistentCookieStore 类：https://gist.github.com/franmontiel/ed12a2295566b7076161 当解决了Cookie的存储后，我们就需要考虑以后我们的每次请求需要在请求的消息头中加入Cookie字段。以上用CookieStore存储下来的Cookie信息都会被保存成HttpCookie形式的信息。我们可以上面的百度例子中看到Cookie的组成样式，所以我们可以提取CookieStore中的信息并组合。12345678910StringBuilder cookieBuilder = new StringBuilder();String divider = &quot;&quot;;for (HttpCookie cookie : getCookies()) &#123; cookieBuilder.append(divider); divider = &quot;;&quot;; cookieBuilder.append(cookie.getName()); cookieBuilder.append(&quot;=&quot;); cookieBuilder.append(cookie.getValue());&#125;cookieString = cookieBuilder.toString(); 然后把这个cookieString在以后的请求中加入到头中，如果你用HttpUrlConnection，你就可以1setRequestProperty(&quot;Cookie&quot;,cookieString); 如果你需要让应用中打开的WebView页面也能共享使用Cookie，则需要使用android.webkit.CookieManager类来设置，简单式例代码如下。注意，第一个参数要使用链接的host部分。这样让web端的不同页面也可以共享这些cookie。123for (HttpCookie cookie : getCookies()) &#123; CookieManager.getInstance().setCookie(Uri.parse(url).getHost(), cookie.toString());&#125; OK，大功告成。 以下是我在Github上开源的一个基于Volley实现的网络层框架，也包括Cookie机制的Http请求，欢迎大家fork：https://github.com/CPPAlien/DaVinci 作者简介彭涛(@彭涛me) 致力于让技术变得易懂且有趣个人博客：http://pengtao.me, GitHub地址：https://github.com/CPPAlien]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity重建时保持Fragment状态的方法]]></title>
    <url>%2F2016-02-18%2Fhold-fragment-state%2F</url>
    <content type="text"><![CDATA[假设场景用Fragment方法实现一个居中的EditText，在EditText中输入一些内容，要求在屏幕旋转后，EditText中已经输入的内容不会被清空。 1，不要重复创建Fragment每次activity被销毁时，当前的fragment状态都会被自动保存，所以如果不用以下方法加以判断，那么每次activity重建都会重复产生fragment。123456FragmentManager fm= getSupportFragmentManager();Fragment fragment = fm.findFragmentById(R.id.second_fragment_container);if ( fragment == null ) &#123; fragment = new SecondFragment(); fm.beginTransaction().add(R.id.second_fragment_container, fragment).commit();&#125; 2，使用setRetainInstance方法设置该方法为true后，可以让fragment在activity被重建时保持实例不变。12345@Overridepublic void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setRetainInstance(true);&#125; 此方法设置后会让activity在重建时的fragment生命周期与activity生命周期产生一些差别。差别如下： onDestroy将不会被调用（但onDetach方法会，因为fragment将会先从当前activity中分离） onCreate将因为fragment没有被重新创建而不会被调用 onAttach和onActivityCreated还将会被调用 3，保存View为全局变量有人会发现，为什么设置了setRetainInstance方法，但是旋转屏幕时，EditText中输入的内容也会被清除呢？这是因为Fragment的onCreateView方法被重新执行了，重新创建了一个新的View，自然以前输入的内容就没有了。此时你可以设置一个全局的View，方法如下：12345678910View view = null;@Nullable@Overridepublic View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; if ( view == null ) &#123; Log.e(&quot;TestFragment&quot;, &quot;view == null&quot;); view = inflater.inflate(R.layout.fragment_second, container, false); &#125; return view;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Fragment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ImageView中的ScaleType详解]]></title>
    <url>%2F2015-12-30%2FImageView-ScaleType%2F</url>
    <content type="text"><![CDATA[官方介绍下面举个例子对以上几点属性逐条说明 准备准备一张400x300的图片，命名为：test_400x300，写一个简单的布局，观察右边preview预览图的变化。从图中我们可以看到，此控件的长宽布局都用in单位，之所以长宽都用in单位，是为了框定一个不受屏幕分辨率的区域。这样一张400x300px的图片放到不同的drawable目录下后，在屏幕上就会占用不同的英寸大小，此时scaleType不同而带来的变化更容易观察。此方面知识如果还不清楚可以参考本人的另一篇博文：《Android布局中的尺寸单位介绍》 FIT_CENTERfitCenter是ImageView控件的默认ScaleType。它表示把一个图片缩放到当前View大小，小于的图片会放大，大图会缩小。事例图片见上文”准备“中的图。 CENTER_INSIDE把图片缩小到ImageView区域中，并居中显示。它与FIT_CENTER的区别在于，如果是小于该控件的图，则不会放大，而是维持图的大小直接居中显示。android:scaleType=”centerInside”test_400x300.png在drawable-hdpi中 CENTER直接把图片居中显示，不进行任何缩放动作，在控件区域内的则显示，不在就不显示。当图片小于控件时，与CENTER_INSIDE作用一样。 android:scaleType=”center”test_400x300.png在drawable-mdpi中注：因为mdpi是指160dpi，所以用400/160大于2in，所以宽度多出的部分就没有显示出来 CENTER_CROP放大或缩小图片直到图片的中间区域恰好可以把控件区域填满。android:scaleType=”centerCrop”test_400x300.png在drawable-mdpi或drawable-hdpi中 FIT_END放大或缩小图片到正好可以放入到空间中的大小，与FIT_CENTER的不同点在于，把图片居下（长大于宽是）或居右（框大于长时）显示。 and android:scaleType=”fitEnd”test_400x300.png在drawable-mdpi或drawable-hdpi中 FIT_START与FIT_END基本相同，只是图片会居左或上显示。 FIT_XY不固定长宽比例的缩小或放大图片，直到用图片把控件区域全部填满。android:scaleType=”fitXY”test_400x300.png在drawable-mdpi或drawable-hdpi中 MATRIX用矩阵的方式绘制，从控件的左上角开始，不缩放图片，与CENTER相似，不同点在于把图片的左上角对上控件的左上角显示，超出控件的部分不显示。 android:scaleType=”matrix”test_400x300.png在drawable-hdpi中 总结以上，除fitXY长宽比例不固定外，其他5中scale方法长宽比例都固定。 作者简介彭涛(@彭涛me) 致力于让技术变得易懂且有趣个人博客：http://pengtao.me, GitHub地址：https://github.com/CPPAlien]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[详解Android源码目录]]></title>
    <url>%2F2015-11-10%2Fdir-android-code%2F</url>
    <content type="text"><![CDATA[首先推荐大家一个很好的，而且没有被墙的android源码查询网站：http://androidxref.com/ 大家可以直接在上面查看源码，而且里面的查询也很方便。如果是第一次查看源码肯定会被里面的目录名整迷糊了，不知道要在哪个目录下查到自己想要的代码。我这边给大家详细介绍下： Bionic - Google自己开发的安卓C运行库。 在这个文件夹下你可以找到c库的源码，如数学计算和其他的一些核心运行C库源码。（注：一般Linux系统使用glibc, bionic主要以BSD许可形式开源，它仅有200KB是glibc的一半，有更高的效率和低内存占用，更适合移动设备） Bootable - 引导 和 启动相关代码。它对广大设备厂商来说是一个福音，很多设备的boot loaders实行这种fastboot协议，比如Nexus One。 Build - 编译系统的实现包含系统所有的核心makefile模板。其中一个很有用的文件 envsetup.sh 可以帮你设定环境变量，编译专有模块和检索一下源码文件。 Cts - 兼容性测试。这个测试套确保编译过程符合Android规格。 Dalvik - Dalvik 虚拟机的实现源码。 Development - 开发相关的一些源码，如sdk、ndk工具。 Device - 这里包括硬件模块代码，不同设备，内容也不同。 External - 包含所有开源项目的代码，如SQLite, Freetype, Webkit 等。 Frameworks - Android框架源码。在这里可以找到Android最核心的实现，比如 包和Activity的管理等。许多的Java与native库映射的api也在这里实现。初期学习源码我们主要关注这个目录下内容。 Hardware - 硬件相关源码，如Android硬件抽象层的实现和规范。这个文件夹还包括所涉及的通信模块实现。 libcore - 核心java库，大部分内容曲子Apache Harmony的类库子集。（Apache Harmony虚拟机间接催生了Davilk虚拟机） libnativehelper - JNI使用的帮助函数 Out - 运行make后生成的一些文件。 Packages - 包含系统默认应用的源码，如联系人、日历、浏览器等。 Prebuilt - 为方便而提前编译好的二进制文件。 System - Android系统核心的源码文件。这是在Dalvik虚拟机和所有java启动前所能运行的最小Linux系统。里面包括init进程、默认的init.rc 脚本 等。 tools - 不同IDE工具 为方便大家理解，再贴出一张Android的架构图 最后再推荐大家一个好用的Chrome插件：Android SDK Search，安装成功后，打开https://developer.android.com 查询某些View或组件的用法时，可以直接查看它的源码。如下，多了一个 view source的按钮。 参考：http://stackoverflow.com/questions/9046572/how-to-understand-the-directory-structure-of-android-root-tree]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android布局中的尺寸单位介绍]]></title>
    <url>%2F2015-11-09%2Fsize-in-android%2F</url>
    <content type="text"><![CDATA[简介：很多刚开始接触Android开发的初学者，虽然会做些简单布局，但是却不明白其深层的意思，只是把布局文件写完了，在真机上调试看到样子就觉得完事了。也不会管这种布局方式是否在其他屏幕手机上合适。这篇文章先从一个最基本的小点入手，主要介绍下Android工程目录下的mdpi、hdpi等目录的意义，和它们与开发中所用到的一些基本单位如sp、dp等的关系。 在介绍开发上的知识之前我们先了解下市面上一些手机规格里面所表达的意义。 以下用荣耀6 plus的屏幕参数作为例子讲解这些参数之间的关系。英寸(inch) 1 inch = 2.54 cm 主屏尺寸：也就是主要显示屏幕对角线的距离屏幕像素密度：ppi（pixels per inch ），意思是，每英寸所含有的像素数量；主屏分辨率：1920x1080像素表示屏幕高度上有1920个像素点，宽度上有1080个像素点； 以上三个参数是有一定关系的，因为对角线是5.5英寸，因像素相对于英寸足够小，我们可以根据勾股定理，计算出对角线上大约有2202.907像素再用这个像素数除以5.5英寸大致得到像素密度为：400.528， 约等于401。所以此处屏幕像素密度为：401ppi 以上是市面上手机的一些参数，而作为Android开发人员，则经常会和以下几个单位打交道：px ： one pixel (像素)dip ：Density-independent pixels(密度无关像素，也可以简写成：dp，代表 1/160 inch，一般都会使用这个单位进行布局)sp ：scale-independent pixels(拉升无关像素，与dp计算规则一致，区别是大小会根据系统设定而变，一般用在字体大小上)还有两个 ：一个是mm 表示毫米，另一个是pt表示点 1/72 inch，开发中不经常用到，这里不做详细介绍。 手机屏幕多种多样，规格各不相同，Android为保证开发者能开发出适配不同屏幕的应用，它把不同屏幕密度做了以下划分； 注意这里的dpi 和ppi某种程度上来说其实是一样的东西。每一种手机都有一个自己ppi，但我们在编程时，这个手机的屏幕就会对应到我们所说的某个dpi，Android程序框架为了方便处理只定义了几种dpi规格，某款手机在知道ppi后，向上找到最接近的dpi作为标准。如下一段代码我们经常用来打印设备密度，来进行不同机型的屏幕适配。12Resources.getSystem().getDisplayMetrics().densityResources.getSystem().getDisplayMetrics().densityDpi 在Nexus 6P中我们会得到density = 3.5，densityDpi = 560，而上网查找Nexus6P手机我们可以知道它的PPI为515，所以它对应到了xxxhdpi这个范围上。3.5就是560 / 160所得。 注：其中mdpi也叫normal size，是第一款基于Android的手机 HTC T-Mobile G1手机的分辨率大小，Android直到 1.6版本才可以支持不同分辨率的屏幕。 这里我们举个例子说明，Android应用在工作时如何展示和选择素材：如果我们开发时，把一个 10x10 像素的图片放到mdpi的素材目录下，布局设置为wrap_content；则这个图片会在手机上占用 (1/16 x 1/16) inch 的空间。这时候同样的一张图片如果运行在不同ppi的手机上，则会不一样，因为虽然在手机上占用的屏幕尺寸一样，但是这个尺寸所包含的像素数量不一样。在高ppi手机上这张图片可能会有模糊；同样如果你把这个10x10像素的图片放到了hdpi目录下，则这个图片就会占用：(1/24 x 1/24)inch的大小，同样的图片则显示的就会更小，也会更精致。因为在同样的尺寸下包含了更多的像素。 这样你就可以根据需要适配机型的物理长宽尺寸，来选择把不同的素材放到不同的文件夹里，以达到最好的显示； 那如果每个文件夹下都有这一张不同分辨率的图片，应用在运行时，Android系统会选择最接近改密度的文件夹目录下的素材，比如上面提到的荣耀 6 plus的401ppi，它向上接近480dpi，所以系统会优先为它选择xxhdpi目录下的素材。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>布局</tag>
      </tags>
  </entry>
</search>